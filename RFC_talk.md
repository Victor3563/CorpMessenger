Author: Виктор Новицкий (@Vitya.novitskiy.05@mail.ru)
Status: [proposed] 
Date: 2025.03.04


---

## Foreword

Цель данного документа — предложить стратегию реализации функционала личных чатов в системе Messenger. Предлагаемое решение должно обеспечить надежное, быстрое и масштабируемое взаимодействие в режиме реального времени между двумя пользователями, с возможностью локального кэширования, корректного сохранения истории и обработки удаления сообщений. Документ описывает текущее состояние системы, выявляет проблемы и предлагает несколько вариантов их решения.

---

## Motivations

Основной мотив — повышение качества пользовательского опыта за счет реализации обмена сообщениями, аналогичного современным мессенджерам (например, Telegram, WhatsApp). Пользователи ожидают мгновенной доставки сообщений, корректного упорядочивания, сохранения истории и возможности удаления сообщений без конфликтов.

---

## Background

На данный момент система Messenger использует PostgreSQL для хранения метаданных (пользователи, чаты и участники), однако функционал личных чатов еще не реализован. Существующий подход не предусматривает реального времени обмена сообщениями и локального кэширования, что снижает конкурентоспособность продукта.

---

## Participants

- **Клиенты:** веб-приложения, обеспечивающие отображение и отправку сообщений.
- **WebSocket сервер:** основной компонент для установления постоянного двунаправленного соединения.
- **PostgreSQL:** персистентное хранилище истории сообщений и данных чатов (с почти реализованной системой версий через миграции).
- **Redis (опционально):** серверный кэш для ускорения доступа к последним N сообщениям.

---

## Options

В рамках реализации личных чатов рассматриваются два основных подхода:
1. Реализация функционала с использованием только клиентского кэширования.
2. Реализация функционала с использованием серверного кэширования (Redis) в дополнение к клиентскому.

---

## Considerations

При выборе решения следует учесть следующие аспекты:
- Надежность и скорость доставки сообщений.
- Корректное упорядочивание сообщений (использование временных меток и/или порядковых номеров).
- Синхронизация локального кэша с серверной историей.
- Обработка конфликтов при удалении сообщений (атомарность операций).
- Интеграция с существующей базой данных PostgreSQL с контролем версий.

---

## Questions

- Какие потенциальные проблемы могут возникнуть при синхронизации клиентского и серверного кэша?
- Как обеспечить атомарность операций удаления сообщений при высокой нагрузке?
- Стоит ли использовать soft delete(Помечаем сообщение в таблицы удаленым и убираем его из поля видимости пользователя, но сообщение хранится в БД) или hard delete(полноценное удаление из таблицы), и как это повлияет на восстановление истории чата?
- Какой подход быстрее и надежнее в условиях масштабируемой системы?

---

## Summary

В этом месте должно стать понятно, что предложенное решение направлено на создание личных чатов с поддержкой обмена сообщениями в реальном времени, локальным и возможно серверным кэшированием, корректным сохранением порядка сообщений и надежной обработкой операций удаления. Это позволит существенно улучшить UX и масштабируемость системы Messenger.

---

## Goals

- Обеспечить мгновенную передачу сообщений между пользователями в режиме реального времени.
- Гарантировать корректное упорядочивание сообщений даже при задержках передачи.
- Реализовать механизм кэширования последних N сообщений для снижения нагрузки на сервер.
- Обеспечить надежное и атомарное удаление сообщений с обработкой конфликтных ситуаций.

---

## Motivation

Изменение предлагается для повышения качества обмена сообщениями, как это реализовано в современных мессенджерах. Это необходимо для улучшения конкурентоспособности продукта и удовлетворения растущих ожиданий пользователей относительно скорости и надежности работы чата.


---

## Design

### Архитектурная схема

Основной подход заключается в установлении соединения с сервером через WebSocket. Сообщения сохраняются в PostgreSQL (с учетом контроля версий), упорядочиваются по временной метке и/или порядковому номеру, а локальный кэш (на клиенте и опционально на сервере с использованием Redis) обеспечивает быстрый доступ к последним N сообщениям.

graph TD
    A[Клиент (Web)]
    B[WebSocket сервер]
    C[PostgreSQL]
    E[Кэш (Redis, опционально)]
    
    A -- HTTP --> B (Это первое действие WebSocket, рукопожатие через HTTP)
    A -- WebSocket <--> B
    B -- Сохранение сообщений, упорядочивание, удаление --> C
    B -- Кэширование (опционально) --> E
    A -- Запрос/Ответ <--> E
    A -- Запрос/Ответ(falback случай для кэша) <--> B <--> C
    A -- HTTP конец связи --> B
    

#### Процесс отправки сообщения

Diagram
    Client := Клиент
    WS := WebSocket сервер
    DB := PostgreSQL
    Cache := Локальный кэш

    Client->>WS: Установить соединение
    WS-->>Client: Подтверждение соединения

    Client->>WS: Отправить сообщение "Привет!"
    WS->>DB: Сохранить сообщение (INSERT, timestamp, body)
    DB-->>WS: Подтверждение сохранения
    WS->>Client: Подтверждение доставки
    WS->>ДругойКлиент: Передача сообщения "Привет!"
    Note_over Client,Cache: Обновление локального кэша последних N сообщений


#### Процесс удаления сообщения

Diagram
    Client := Клиент
    WS := WebSocket сервер
    DB := PostgreSQL
    Cache := Локальный кэш

    Client->>WS: Запрос на удаление сообщения (ID)
    WS->>DB: Выполнить транзакцию (soft delete или hard delete)
    DB-->>WS: Подтверждение операции
    WS->>Client: Уведомление об удалении
    WS->>ДругойКлиент: Рассылка уведомления
    Note_over Cache: Обновление локального кэша (удаление сообщения)


#### Хранение и упорядочивание сообщений

Хранение: Сообщения сохраняются с полями:

id – уникальный идентификатор.
chat_id – идентификатор личного чата.
sender_id – идентификатор отправителя.
content – текст или ссылка на мультимедиа.
created_at – временная метка создания.
sequence – (опционально) числовой порядковый номер для строгой сортировки.
deleted(Опционально) – флаг для soft delete.
Упорядочивание: При выборке сообщений сервер сортирует их по created_at или sequence, что обеспечивает правильный порядок даже при задержках.
P.S Я пока не понял, стоит ли сортировать только по времени. Об этом надо думать, может в часовых поясах появится проблема или кэши, но тоже надо думать. Например если пользователю показывают во сколько он отправил сообщение, то можно на сервере хранить в едином часовом поясе, а на устройстве пользователе переводить в нужный часавой пояс или в момент передачи. Но вроде при моей схеме все окей в любом случае должно быть. Просто синхронизировать время отправки как время получения сообщения сервером, а не момент отправки пользователем. Но опять же, если пользователь отправляет сообщения очень близко по времени, то первое тяжелое сообщение может прийти позже чем второе быстрое и тогда порядок рушится. Вообщем подумаю об этом в момент реализации

Удаление:
При удалении сообщение либо помечается как удалённое (soft delete), либо удаляется физически (hard delete). Транзакции PostgreSQL обеспечивают атомарность операций, предотвращая конфликты при одновременных запросах.

---

## Dependencies
Данное решение зависит от следующих систем:

PostgreSQL: Персистентное хранение сообщений и метаданных чатов с контролем версий через миграции.
Redis (опционально): Серверное кэширование для быстрого доступа к последним N сообщениям.
WebSocket сервер: Обеспечивает двунаправленную связь в режиме реального времени.

---

## Possible Approaches

### Option 1: Использование только клиентского кэширования

Преимущества:

Простота реализации.
Нет необходимости в дополнительной серверной инфраструктуре для кэширования.

Недостатки:

Потеря истории при удалении кэша(смена устройство и тд) с клиента.
Необходимость частых обращений к серверу для синхронизации, что может увеличить нагрузку.


### Option 2: Использование серверного кэширования (Redis) в дополнение к клиентскому кэшированию

Преимущества:

Быстрый доступ к истории чата и снижение нагрузки на базу данных.
Синхронизация истории чата между разными устройствами.
Более высокая стабильность и масштабируемость.

Недостатки:

Усложнение архитектуры.
Необходимость поддержки дополнительного компонента (Redis).
Возможны дополнительные сложности при синхронизации клиентского и серверного кэша.

---

## Conclusion

Я рекомендую реализовать функционал личных чатов с использованием подхода, описанного в Option 1 — упрошенное решение на данном этапе проекта подходит под задачи поставленные перед конечным продуктом, а усложнение, несмотря на положительное влияние на возможности мессенджера, создаст излишние сложности в реализации проекта, не соответсвуюшие задачам, которые будут стоять перед продуктом: например нагрузка на сервер будет маленькой, так как пользователи будут ограничены сотрудниками компании. В будущем возможен переход на систему 2. Так же стоит использовать только hard delete для упрощения работы с базой данных.

---

## Referenc

Шаблон RFC - https://gist.github.com/auycro/7d49fe197d6e5e1f5b2058c39a678a01
Референс RFC - https://datatracker.ietf.org/doc/html/rfc2045
WebSocket - https://habr.com/ru/articles/886802/
Redis - https://habr.com/ru/companies/wunderfund/articles/685894/

---